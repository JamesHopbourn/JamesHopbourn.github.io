---
title: CTF 压缩包伪加密
date: 2020-01-01 09:39
tags: CTF
categories: 
---

## 原理
第一行 0x06 位置处的 0000 是全局方式标记，看是否加密，可以只看第一个00，第二字节00可以忽略。00表示无加密，01表示有加密。只要是偶数就是无加密，例如00,02,04等，奇数就是有加密，例如01,03,09 等。使用 Synalyze It! Pro 即可看到 ZIP 压缩包的数据结构。

<!-- more -->

![](/media/zipfakeencrypt.png)

<code> te <font color="red"> st </font> </code>

## 新建压缩包：

```
vim flag.txt
7z a -tzip flag.zip flag.txt
```

请注意，使用不同压缩命令得到的压缩包内容虽然一样，但是文件结构却略有区别，在这个例子里使用 7z 命令进行压缩，使用其他命令压缩将会得到不同结果。

```
7z 压缩结果：
00000000: 504b 0304 0a03 0000 0000 af66 2650 08fd  PK.........f&P..
00000010: 825a 0400 0000 0400 0000 0800 0000 666c  .Z............fl
00000020: 6167 2e74 7874 3132 330a 504b 0102 3f03  ag.txt123.PK..?.
00000030: 0a03 0000 0000 af66 2650 08fd 825a 0400  .......f&P...Z..
00000040: 0000 0400 0000 0800 2400 0000 0000 0000  ........$.......
00000050: 2080 a481 0000 0000 666c 6167 2e74 7874   .......flag.txt
00000060: 0a00 2000 0000 0000 0100 1800 0081 763d  .. ...........v=
00000070: 4dc4 d501 0043 6249 4dc4 d501 0081 763d  M....CbIM.....v=
00000080: 4dc4 d501 504b 0506 0000 0000 0100 0100  M...PK..........
00000090: 5a00 0000 2a00 0000 0000                 Z...*.....

zip 压缩结果：
00000000: 504b 0304 0a00 0000 0000 af66 2650 08fd  PK.........f&P..
00000010: 825a 0400 0000 0400 0000 0800 1c00 666c  .Z............fl
00000020: 6167 2e74 7874 5554 0900 034a bd12 5e55  ag.txtUT...J..^U
00000030: bd12 5e75 780b 0001 04f5 0100 0004 1400  ..^ux...........
00000040: 0000 3132 330a 504b 0102 1e03 0a00 0000  ..123.PK........
00000050: 0000 af66 2650 08fd 825a 0400 0000 0400  ...f&P...Z......
00000060: 0000 0800 1800 0000 0000 0100 0000 a481  ................
00000070: 0000 0000 666c 6167 2e74 7874 5554 0500  ....flag.txtUT..
00000080: 034a bd12 5e75 780b 0001 04f5 0100 0004  .J..^ux.........
00000090: 1400 0000 504b 0506 0000 0000 0100 0100  ....PK..........
000000a0: 4e00 0000 4600 0000 0000                 N...F.....

macOS 归档实用工具压缩结果：
00000000: 504b 0304 1400 0800 0800 af66 2650 0000  PK.........f&P..
00000010: 0000 0000 0000 0000 0000 0800 1000 666c  ..............fl
00000020: 6167 2e74 7874 5558 0c00 70bd 125e 4abd  ag.txtUX..p..^J.
00000030: 125e f501 1400 3334 32e6 0200 504b 0708  .^....342...PK..
00000040: 08fd 825a 0600 0000 0400 0000 504b 0102  ...Z........PK..
00000050: 1503 1400 0800 0800 af66 2650 08fd 825a  .........f&P...Z
00000060: 0600 0000 0400 0000 0800 0c00 0000 0000  ................
00000070: 0000 0040 a481 0000 0000 666c 6167 2e74  ...@......flag.t
00000080: 7874 5558 0800 70bd 125e 4abd 125e 504b  xtUX..p..^J..^PK
00000090: 0506 0000 0000 0100 0100 4200 0000 4c00  ..........B...L.
000000a0: 0000 0000                                ....
```


## 加密

```
导出十六进制：
xxd flag.zip flag.dump
使用 sed 配合正则表达式进行替换：
sed -i '' -E '1s/[0-9]{4}/0100/4' flag.dump
导出新压缩包：
xxd -r flag.dump > FakeEncrypt-flag.zip
```

## 破解

```
导出十六进制：
xxd FakeEncrypt-flag.zip flag.dump
使用 sed 配合正则表达式进行替换：
sed -i '' -E '1s/[0-9]{4}/0000/4' flag.dump
导出新压缩包：
xxd -r flag.dump > UnFakeEncrypt-flag.zip
```

## 彩蛋
嫌这样操作太麻烦，在实际运用中不方便可以添加一个 function 到 zshrc 里面：

```
fakeency(){
xxd $1 $1.dump
sed -i '' -E '1s/[0-9]{4}/0100/4' $1.dump
xxd -r $1.dump > FakeEncrypt-$1
rm $1.dump
}

unency(){
xxd $1 $1.dump
sed -i '' -E '1s/[0-9]{4}/0000/4' $1.dump
xxd -r $1.dump > UnFakeEncrypt-$1
rm $1.dump
}
```
